## 응집도란?
- 데이터와 로직 사이의 관계가 얼마나 강한지를 나타내는 지표.
- 높은 구조는 변경하기 쉬우며, 낮은 구조는 변경 시 문제가 발생하기 쉽다.

## 1. static 메서드 오용
- static 메서드는 인스턴스 변수를 사용할 수 없다. 당연히 응집도가 낮아질 수 밖에 없다.
- 어떠한 상황에서 static 메서드를 사용해야 좋을까?
  * 응지도의 영향을 받지 않는 경우, 예를 들어 로그 출력 전용, 포맷 변환 등.
  * 횡단 관심사

## 2. 초기화 로직이 분산되면 팩토리 메서드를 쓰자
- [로직이 데이터와 응집되어 있는 것처럼 보인다.](./02_giftpoint/01_GiftPoint.ts)
  * 생성자를 public으로 만들면 의도하지 않은 용도로 사용될 수 있다.
  * 관련된 로직이 분산되기 때문에 유지 보수하기 힘들어진다.
  * 예를 들어 회원 가입 포인트를 변경하고 싶을 때, 소스코드 전체를 확인해야 한다.
    ```ts
    const standardMembershipPoint = new GiftPoint(3000);
    const premiumMembershipPoint = new GiftPoint(10000);
    ```
- [private 생성자 + 팩토리 메서드를 사용해 목적에 따라 초기화하기](./02_giftpoint/01_GiftPoint.ts)
  * 초기화 로직의 분산을 막으려면 생성자를 private로 만들고, 목적에 따라 팩토리 메서드를 만든다.
  * 생성 로직이 너무 많아지면 팩토리 클래스 고려.

## 3. 매개변수가 너무 많은 경우 클래스로 만들자
- [많은 매개변수의 문제점](./03_magicpoint/01_magicpoint.ts)
  * 많은 매개변수를 받는 메서드는 실수로 잘못된 값을 대입할 가능성이 높다.
  * 매개변수가 많다는 것은 많은 기능을 처리하고 싶다는 의미, 처리할게 많아지면 로직이 복잡해지거나 중복코드가 생길 가능성이 높아진다.
- [개념적으로 의미 있는 클래스를 만들어야 한다.](./03_magicpoint/02_magicpoint.ts)
  * 기본 자료형으로만 구현하려고 하면, 데이터를 사용한 계산과 제어 로직이 모두 분산된다.
  * 매개변수가 많으면 데이터 하나하나를 매개변수로 다루지 말고, 그 데이터를 인스턴스 변수로 갖는 클래스를 만들고 활용하는 설계로 변경해보자.

## 4. 묻지말고 명령해라, 메서드 체인 지양해라
- 메서드 체인 = .(점)으로 여러 메서드를 연결해서 리턴 값의 요소에 차례차례 접근하는 방법. [Sample Code](./04_many_args/01_equipArmor.ts)
  * 이렇게 접근하는 요소, 요소 마다 사양이 조금이라도 변경되면, 해당 요소에 접근하고 있던 모든 코드를 확인하고 수정해야 한다.
  * 어디서든 아무 요소에나 접근할 수 있는 구조이므로, 전역 변수보다 훨씬 악질적이다.
- 묻지말고 명령하기
  * 다른 객체 내부 상태(변수)를 기반으로 판단하거나 제어하려고 하지 말고, **메서드로 명령**해서 객체가 알아서 팡단하고 제어하도록 설계하라. [Sample Code](./04_many_args/02_equipArmor.ts)
